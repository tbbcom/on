/* tbb-imgtool.js — core logic for the Image Converter (c) 2025 The Bukit Besi via https://www.thebukitbesi.com
*/
(function () {
  'use strict';

  const $ = (id) => document.getElementById(id);
  const el = {
    dropzone: $('tbb-dropzone'),
    fileInput: $('tbb-file'),
    formatSelect: $('tbb-format'),
    qualityWrap: $('tbb-quality-wrap'),
    qualitySlider: $('tbb-quality'),
    qualityVal: $('tbb-quality-val'),
    resizeToggle: $('tbb-resize-toggle'),
    resizeStatus: $('tbb-resize-status'),
    resizeFields: $('tbb-resize-fields'),
    maxW: $('tbb-maxw'),
    maxH: $('tbb-maxh'),
    keepAspect: $('tbb-keep-aspect'),
    bgColor: $('tbb-bg'),
    convertBtn: $('tbb-convert'),
    clearBtn: $('tbb-clear'),
    queue: $('tbb-queue'),
    results: $('tbb-results'),
    progress: $('tbb-progress'),
    progressInner: $('tbb-progress-inner'),
    progressText: $('tbb-progress-text'),
    downloadAllWrap: $('tbb-download-all'),
    zipBtn: $('tbb-zip'),
    notice: $('tbb-smart-resize-notice'),
    faq: document.getElementById('tbb-faq')
  };

  if (!el.dropzone) return; // mounted in fragments too

  let filesToProcess = [];
  let converted = [];
  const SMART_RESIZE_THRESHOLD = 2000;
  const SMART_RESIZE_VALUE = 1920;

  const formatBytes = (b, d = 2) => {
    if (!b) return '0 Bytes';
    const k = 1024, s = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(b) / Math.log(k));
    return `${parseFloat((b / Math.pow(k, i)).toFixed(d))} ${s[i]}`;
  };

  const setRangeFill = () => {
    const min = +el.qualitySlider.min, max = +el.qualitySlider.max, val = +el.qualitySlider.value;
    const percent = (val - min) * 100 / (max - min);
    el.qualitySlider.style.setProperty('--value-percent', `${percent}%`);
    el.qualityVal.textContent = `${val}%`;
  };

  const updateQueue = () => {
    el.queue.innerHTML = filesToProcess.map((file, i) => `
      <div class="tbb-file">
        <div>
          <div class="tbb-file-name">${file.name}</div>
          <div class="tbb-file-meta">${formatBytes(file.size)}</div>
        </div>
        <button class="tbb-remove-file" data-index="${i}" aria-label="Remove ${file.name}">×</button>
      </div>`).join('');
    el.convertBtn.disabled = filesToProcess.length === 0;
  };

  const maybeSmartResizeNotice = async (file) => {
    try {
      let w, h;
      if ('createImageBitmap' in window) {
        const bmp = await createImageBitmap(file);
        w = bmp.width; h = bmp.height; bmp.close && bmp.close();
      } else {
        w = await new Promise((res, rej) => {
          const fr = new FileReader();
          fr.onload = e => {
            const img = new Image();
            img.onload = () => res({ w: img.width, h: img.height });
            img.onerror = rej; img.src = e.target.result;
          };
          fr.onerror = rej; fr.readAsDataURL(file);
        }).then(o => o.w).catch(() => null);
        h = await new Promise((res, rej) => {
          const fr = new FileReader();
          fr.onload = e => {
            const img = new Image();
            img.onload = () => res(img.height);
            img.onerror = rej; img.src = e.target.result;
          };
          fr.onerror = rej; fr.readAsDataURL(file);
        }).catch(() => null);
      }
      if (!w || !h) return;
      if (w > SMART_RESIZE_THRESHOLD || h > SMART_RESIZE_THRESHOLD) {
        el.resizeToggle.checked = true;
        el.resizeFields.hidden = false;
        el.resizeStatus.textContent = 'On';
        if (!el.maxW.value && !el.maxH.value) {
          el.maxW.value = SMART_RESIZE_VALUE;
          el.maxH.value = '';
        }
        el.notice.hidden = false;
      }
    } catch {}
  };

  const handleFiles = (files) => {
    const imgs = [...files].filter(f => (f.type || '').startsWith('image/'));
    if (!imgs.length) return;
    filesToProcess.push(...imgs);
    updateQueue();
    // run smart resize detection on first large file
    maybeSmartResizeNotice(imgs[0]);
  };

  const drawToCanvas = async (file) => {
    let width, height, source;
    if ('createImageBitmap' in window) {
      source = await createImageBitmap(file);
      width = source.width; height = source.height;
    } else {
      source = await new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = e => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject; img.src = e.target.result;
        };
        fr.onerror = reject; fr.readAsDataURL(file);
      });
      width = source.width; height = source.height;
    }

    const original = { width, height };
    // resizing
    if (el.resizeToggle.checked) {
      const maxW = parseInt(el.maxW.value, 10), maxH = parseInt(el.maxH.value, 10);
      if (maxW || maxH) {
        const ratio = width / height;
        if (el.keepAspect.checked) {
          if (maxW && width > maxW) { width = maxW; height = Math.round(width / ratio); }
          if (maxH && height > maxH) { height = maxH; width = Math.round(height * ratio); }
        } else {
          if (maxW) width = maxW;
          if (maxH) height = maxH;
        }
      }
    }

    const canvas = (typeof OffscreenCanvas !== 'undefined')
      ? new OffscreenCanvas(width, height)
      : Object.assign(document.createElement('canvas'), { width, height });

    const ctx = canvas.getContext('2d');
    const outFmt = el.formatSelect.value;

    // Fill background for non-alpha formats
    if (outFmt === 'image/jpeg' || outFmt === 'image/bmp') {
      ctx.fillStyle = el.bgColor.value || '#ffffff';
      ctx.fillRect(0, 0, width, height);
    }
    ctx.drawImage(source, 0, 0, width, height);
    source.close && source.close();

    const quality = parseInt(el.qualitySlider.value, 10) / 100;
    const blob = await new Promise((resolve) => {
      // Note: PNG/BMP ignore quality param
      if (canvas.convertToBlob) {
        canvas.convertToBlob({ type: outFmt, quality }).then(resolve);
      } else {
        canvas.toBlob(resolve, outFmt, quality);
      }
    });

    const base = file.name.replace(/\.[^.]+$/, '');
    const ext = { 'image/jpeg':'jpg', 'image/png':'png', 'image/webp':'webp', 'image/bmp':'bmp' }[outFmt] || 'bin';
    const name = `${base}.${ext}`;
    return { name, blob, originalDims: original, newDims: { width, height }, originalSize: file.size };
  };

  const resetUI = () => {
    filesToProcess = [];
    converted = [];
    el.queue.innerHTML = '';
    el.results.innerHTML = '';
    el.progress.hidden = true;
    el.downloadAllWrap.hidden = true;
    el.fileInput.value = '';
    el.convertBtn.disabled = true;
    el.notice.hidden = true;
    el.progress.setAttribute('aria-valuenow', '0');
    el.progressInner.style.width = '0%';
  };

  // Events
  el.dropzone.addEventListener('click', () => el.fileInput.click());
  el.fileInput.addEventListener('change', () => handleFiles(el.fileInput.files));

  ['dragenter','dragover','dragleave','drop'].forEach(ev =>
    el.dropzone.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); })
  );
  ['dragenter','dragover'].forEach(ev =>
    el.dropzone.addEventListener(ev, () => el.dropzone.classList.add('tbb-hover'))
  );
  ['dragleave','drop'].forEach(ev =>
    el.dropzone.addEventListener(ev, () => el.dropzone.classList.remove('tbb-hover'))
  );
  el.dropzone.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
  document.addEventListener('paste', e => e.clipboardData && handleFiles(Array.from(e.clipboardData.files)));

  el.queue.addEventListener('click', e => {
    const btn = e.target.closest('.tbb-remove-file');
    if (!btn) return;
    filesToProcess.splice(Number(btn.dataset.index), 1);
    updateQueue();
  });

  el.formatSelect.addEventListener('change', () => {
    const show = ['image/jpeg','image/webp'].includes(el.formatSelect.value);
    el.qualityWrap.hidden = !show;
  });

  el.qualitySlider.addEventListener('input', setRangeFill);
  el.resizeToggle.addEventListener('change', () => {
    el.resizeFields.hidden = !el.resizeToggle.checked;
    el.resizeStatus.textContent = el.resizeToggle.checked ? 'On' : 'Off';
  });
  el.clearBtn.addEventListener('click', resetUI);

  el.convertBtn.addEventListener('click', async () => {
    if (!filesToProcess.length) return;
    converted = [];
    el.results.innerHTML = '';
    el.progress.hidden = false;

    const total = filesToProcess.length;
    let done = 0;

    for (const f of filesToProcess) {
      try {
        // yield to UI between files
        await new Promise(r => requestAnimationFrame(r));
        const result = await drawToCanvas(f);
        converted.push(result);

        const url = URL.createObjectURL(result.blob);
        const newSize = result.blob.size;
        const delta = ((newSize - result.originalSize) * 100 / result.originalSize);
        const pc = (Math.round(delta * 10) / 10).toFixed(1);

        el.results.insertAdjacentHTML('beforeend', `
          <div class="tbb-file">
            <div>
              <div class="tbb-file-name">${result.name}</div>
              <div class="tbb-file-meta">
                ${result.originalDims.width}×${result.originalDims.height} → ${result.newDims.width}×${result.newDims.height}<br/>
                ${formatBytes(result.originalSize)} → ${formatBytes(newSize)}
                <strong>(${delta>0?'+':''}${pc}%)</strong>
              </div>
            </div>
            <a href="${url}" download="${result.name}" class="tbb-link" data-url="${url}">Download</a>
          </div>
        `);
      } catch (e) {
        el.results.insertAdjacentHTML('beforeend', `
          <div class="tbb-file"><div class="tbb-file-name">Failed to convert ${f.name}</div></div>
        `);
      } finally {
        done++;
        const pct = Math.round((done * 100) / total);
        el.progressInner.style.width = pct + '%';
        el.progressText.textContent = `Processed ${done} of ${total}...`;
        el.progress.setAttribute('aria-valuenow', String(pct));
      }
    }

    el.progressText.textContent = 'Conversion complete!';
    if (converted.length > 1 && window.JSZip) {
      el.downloadAllWrap.hidden = false;
    }
  });

  // Revoke object URLs after click (delay to allow download to start)
  el.results.addEventListener('click', (e) => {
    const a = e.target.closest('a.tbb-link');
    if (!a) return;
    const href = a.getAttribute('data-url');
    setTimeout(() => href && URL.revokeObjectURL(href), 4000);
  });

  el.zipBtn.addEventListener('click', async () => {
    if (!window.JSZip) return;
    const zip = new JSZip();
    converted.forEach(c => zip.file(c.name, c.blob));
    const blob = await zip.generateAsync({ type: 'blob' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'tbb-converted-images.zip';
    document.body.appendChild(a);
    a.click();
    a.remove(); setTimeout(() => URL.revokeObjectURL(url), 4000);
  });

  // Init
  el.qualityWrap.hidden = !['image/jpeg','image/webp'].includes(el.formatSelect.value);
  el.convertBtn.disabled = true;
  setRangeFill();
})();
